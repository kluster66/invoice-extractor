AWSTemplateFormatVersion: '2010-09-09'
Description: Déploiement de l'outil d'extraction de factures PDF avec AWS Bedrock - Version corrigée

Parameters:
  EnvironmentName:
    Type: String
    Description: Nom de l'environnement (dev, staging, prod)
    Default: dev
  
  BucketName:
    Type: String
    Description: Nom du bucket S3 pour les factures
    Default: invoice-input-bucket
  
  TableName:
    Type: String
    Description: Nom de la table DynamoDB
    Default: invoices-extractor
  
  BedrockModelId:
    Type: String
    Description: ID du modèle Bedrock à utiliser
    Default: meta.llama3-1-70b-instruct-v1:0

Resources:
  # S3 Bucket pour les factures
  InvoiceInputBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref BucketName
      VersioningConfiguration:
        Status: Enabled
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Application
          Value: invoice-extractor

  # Table DynamoDB pour les factures extraites
  InvoicesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Ref TableName
      AttributeDefinitions:
        - AttributeName: invoice_id
          AttributeType: S
        - AttributeName: numero_facture
          AttributeType: S
        - AttributeName: date_facture
          AttributeType: S
        - AttributeName: fournisseur
          AttributeType: S
      KeySchema:
        - AttributeName: invoice_id
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: numero_facture-index
          KeySchema:
            - AttributeName: numero_facture
              KeyType: HASH
          Projection:
            ProjectionType: ALL
          ProvisionedThroughput:
            ReadCapacityUnits: 5
            WriteCapacityUnits: 5
        - IndexName: date_facture-index
          KeySchema:
            - AttributeName: date_facture
              KeyType: HASH
          Projection:
            ProjectionType: ALL
          ProvisionedThroughput:
            ReadCapacityUnits: 5
            WriteCapacityUnits: 5
        - IndexName: fournisseur-index
          KeySchema:
            - AttributeName: fournisseur
              KeyType: HASH
          Projection:
            ProjectionType: ALL
          ProvisionedThroughput:
            ReadCapacityUnits: 5
            WriteCapacityUnits: 5
      ProvisionedThroughput:
        ReadCapacityUnits: 5
        WriteCapacityUnits: 5
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Application
          Value: invoice-extractor

  # Rôle IAM pour Lambda
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: InvoiceExtractorPermissions
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                  - s3:ListBucket
                Resource:
                  - !Sub arn:aws:s3:::${BucketName}
                  - !Sub arn:aws:s3:::${BucketName}/*
              - Effect: Allow
                Action:
                  - dynamodb:DescribeTable
                  - dynamodb:CreateTable
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:BatchWriteItem
                Resource: !GetAtt InvoicesTable.Arn
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:ListFoundationModels
                Resource: '*'
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName

  # Fonction Lambda
  InvoiceExtractorLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub invoice-extractor-${EnvironmentName}
      Description: Extrait les informations de factures PDF avec Bedrock
      Runtime: python3.10
      Handler: main.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import logging
          from typing import Dict, Any
          from datetime import datetime
          from pathlib import Path
          
          # Configuration du logging
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)
          
          class PDFExtractor:
              """Extracteur de texte PDF avec PyPDF2 et pdfplumber"""
              def extract_text(self, pdf_path: str) -> str:
                  try:
                      import PyPDF2
                      with open(pdf_path, 'rb') as file:
                          reader = PyPDF2.PdfReader(file)
                          text = ""
                          for page in reader.pages:
                              text += page.extract_text() + "\n"
                      return text if text.strip() else self._extract_with_pdfplumber(pdf_path)
                  except Exception as e:
                      logger.warning(f"PyPDF2 échoué: {e}, essai pdfplumber")
                      return self._extract_with_pdfplumber(pdf_path)
              
              def _extract_with_pdfplumber(self, pdf_path: str) -> str:
                  try:
                      import pdfplumber
                      with pdfplumber.open(pdf_path) as pdf:
                          text = ""
                          for page in pdf.pages:
                              text += page.extract_text() + "\n"
                      return text
                  except Exception as e:
                      logger.error(f"pdfplumber échoué: {e}")
                      raise ValueError(f"Impossible d'extraire le texte du PDF: {e}")
          
          class Config:
              """Configuration intelligente AWS"""
              AWS_REGION = os.getenv("AWS_REGION", "us-west-2")
              BEDROCK_MODEL_ID = os.getenv("BEDROCK_MODEL_ID", "meta.llama3-1-70b-instruct-v1:0")
              DYNAMODB_TABLE_NAME = os.getenv("DYNAMODB_TABLE_NAME", "invoices")
              BEDROCK_MAX_TOKENS = int(os.getenv("BEDROCK_MAX_TOKENS", "1000"))
              BEDROCK_TEMPERATURE = float(os.getenv("BEDROCK_TEMPERATURE", "0.1"))
          
          class DynamoDBClient:
              """Client DynamoDB simplifié"""
              def __init__(self, region: str = None, table_name: str = None):
                  self.region = region or Config.AWS_REGION
                  self.table_name = table_name or Config.DYNAMODB_TABLE_NAME
                  self.client = boto3.client("dynamodb", region_name=self.region)
                  self._ensure_table_exists()
              
              def _ensure_table_exists(self):
                  try:
                      self.client.describe_table(TableName=self.table_name)
                      logger.info(f"Table DynamoDB '{self.table_name}' existe déjà")
                  except Exception as e:
                      logger.warning(f"Table non trouvée: {e}, création non nécessaire (gérée par CloudFormation)")
              
              def save_invoice_data(self, invoice_data: Dict[str, Any]) -> str:
                  import uuid
                  invoice_id = str(uuid.uuid4())
                  item = {
                      'invoice_id': {'S': invoice_id},
                      'created_at': {'S': datetime.utcnow().isoformat()},
                      'raw_data': {'S': json.dumps(invoice_data, ensure_ascii=False)}
                  }
                  for key, value in invoice_data.items():
                      if value is not None:
                          if isinstance(value, str):
                              item[key] = {'S': value}
                          elif isinstance(value, (int, float)):
                              item[key] = {'N': str(value)}
                          elif isinstance(value, bool):
                              item[key] = {'BOOL': value}
                          else:
                              item[key] = {'S': str(value)}
                  self.client.put_item(TableName=self.table_name, Item=item)
                  logger.info(f"Facture sauvegardée avec ID: {invoice_id}")
                  return invoice_id
          
          class BedrockClient:
              """Client Bedrock simplifié"""
              def __init__(self, region: str = None, model_id: str = None):
                  self.region = region or Config.AWS_REGION
                  self.model_id = model_id or Config.BEDROCK_MODEL_ID
                  self.client = boto3.client("bedrock-runtime", region_name=self.region)
                  logger.info(f"Client Bedrock initialisé (modèle: {self.model_id}, région: {self.region})")
              
              def extract_invoice_data(self, prompt: str) -> Dict[str, Any]:
                  import re
                  request_body = {
                      "prompt": prompt,
                      "max_gen_len": Config.BEDROCK_MAX_TOKENS,
                      "temperature": Config.BEDROCK_TEMPERATURE,
                      "top_p": 0.9
                  }
                  response = self.client.invoke_model(
                      modelId=self.model_id,
                      body=json.dumps(request_body).encode('utf-8')
                  )
                  response_body = json.loads(response['body'].read())
                  response_text = response_body.get("generation", "").strip()
                  logger.info(f"Réponse Bedrock: {len(response_text)} caractères")
                  
                  # Extraction JSON
                  json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
                  if json_match:
                      try:
                          return json.loads(json_match.group(0))
                      except:
                          pass
                  return {"error": "Aucun JSON valide trouvé", "raw_response": response_text[:500]}
          
          class InvoiceExtractor:
              """Classe principale d'extraction"""
              def __init__(self, region: str = None):
                  self.region = region or Config.AWS_REGION
                  self.pdf_extractor = PDFExtractor()
                  self.bedrock_client = BedrockClient(region=self.region)
                  self.dynamodb_client = DynamoDBClient(region=self.region)
              
              def extract_from_pdf(self, pdf_path: str, filename: str) -> Dict[str, Any]:
                  pdf_text = self.pdf_extractor.extract_text(pdf_path)
                  if not pdf_text:
                      raise ValueError(f"Aucun texte extrait du PDF: {pdf_path}")
                  
                  prompt = f"""Analyse ce document PDF.
          
          Tu es un expert comptable. En te basant sur ces données : {pdf_text[:5000]}
          
          Extrais les informations suivantes et formate-les en JSON strict (sans markdown, juste le code brut).
          
          Champs à extraire :
            - fournisseur (Nom de la société émettrice)
            - montant_ht (Nombre uniquement)
            - numero_facture
            - date_facture (Format YYYY-MM-DD)
            - Le numero Chrono du document
            - La période de couverture
            - nom du fichier que tu trouves ici {filename}
          
          Si une info est manquante, mets null."""
                  
                  extracted_data = self.bedrock_client.extract_invoice_data(prompt)
                  extracted_data["filename"] = filename
                  extracted_data["extraction_date"] = datetime.utcnow().isoformat()
                  extracted_data["pdf_path"] = pdf_path
                  return extracted_data
              
              def process_s3_event(self, event: Dict[str, Any]) -> Dict[str, Any]:
                  try:
                      s3_event = event["Records"][0]["s3"]
                      bucket = s3_event["bucket"]["name"]
                      key = s3_event["object"]["key"]
                      filename = Path(key).name
                      
                      logger.info(f"Traitement du fichier: {filename} depuis {bucket}/{key}")
                      
                      s3_client = boto3.client("s3", region_name=self.region)
                      local_path = f"/tmp/{filename}"
                      s3_client.download_file(bucket, key, local_path)
                      
                      extracted_data = self.extract_from_pdf(local_path, filename)
                      item_id = self.dynamodb_client.save_invoice_data(extracted_data)
                      
                      if os.path.exists(local_path):
                          os.remove(local_path)
                      
                      return {
                          "statusCode": 200,
                          "body": json.dumps({
                              "message": "Facture traitée avec succès",
                              "invoice_id": item_id,
                              "data": extracted_data
                          })
                      }
                  except Exception as e:
                      logger.error(f"Erreur lors du traitement: {str(e)}")
                      return {
                          "statusCode": 500,
                          "body": json.dumps({
                              "error": str(e),
                              "message": "Erreur lors du traitement de la facture"
                          })
                      }
          
          def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:
              region = os.getenv("AWS_REGION")
              extractor = InvoiceExtractor(region=region)
              return extractor.process_s3_event(event)
      Timeout: 300
      MemorySize: 1024
      Environment:
        Variables:
          DYNAMODB_TABLE_NAME: !Ref TableName
          S3_INPUT_BUCKET: !Ref BucketName
          BEDROCK_MODEL_ID: !Ref BedrockModelId
          ENVIRONMENT_NAME: !Ref EnvironmentName
          LOG_LEVEL: INFO
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Application
          Value: invoice-extractor

  # Permission pour S3 d'appeler Lambda
  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref InvoiceExtractorLambda
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceArn: !Sub arn:aws:s3:::${BucketName}

  # CloudWatch Log Group pour Lambda
  LambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/invoice-extractor-${EnvironmentName}
      RetentionInDays: 30

Outputs:
  BucketName:
    Description: Nom du bucket S3 pour les factures
    Value: !Ref BucketName
  
  TableName:
    Description: Nom de la table DynamoDB
    Value: !Ref TableName
  
  LambdaFunctionName:
    Description: Nom de la fonction Lambda
    Value: !Ref InvoiceExtractorLambda
  
  LambdaFunctionArn:
    Description: ARN de la fonction Lambda
    Value: !GetAtt InvoiceExtractorLambda.Arn
  
  S3BucketArn:
    Description: ARN du bucket S3
    Value: !GetAtt InvoiceInputBucket.Arn
  
  DynamoDBTableArn:
    Description: ARN de la table DynamoDB
    Value: !GetAtt InvoicesTable.Arn
  
  LambdaConsoleUrl:
    Description: URL de la console Lambda
    Value: !Sub https://${AWS::Region}.console.aws.amazon.com/lambda/home?region=${AWS::Region}#/functions/${InvoiceExtractorLambda}
  
  S3ConsoleUrl:
    Description: URL de la console S3
    Value: !Sub https://s3.console.aws.amazon.com/s3/buckets/${BucketName}
